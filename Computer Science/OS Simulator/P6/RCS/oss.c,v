head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2015.11.9.15.53.27;	author o-cho;	state Exp;
branches;
next	1.5;

1.5
date	2015.11.9.13.02.11;	author o-cho;	state Exp;
branches;
next	1.4;

1.4
date	2015.11.8.08.00.28;	author o-cho;	state Exp;
branches;
next	1.3;

1.3
date	2015.11.8.05.59.06;	author o-cho;	state Exp;
branches;
next	1.2;

1.2
date	2015.11.7.15.57.40;	author o-cho;	state Exp;
branches;
next	1.1;

1.1
date	2015.11.6.09.30.07;	author o-cho;	state Exp;
branches;
next	;


desc
@proj start
@


1.6
log
@fixed majoiry bug issue
fkixed dead lock issue
improved the avg wait time algorithm
@
text
@#include "oss.h"                            // IPC Data structure

int ShmID;                                
ShmPTR_t *ShmPTR;                              
int SemID_clock;                              
int SemID_res;                              
int signum;                                 
char msgerr[50] = "";                           
int child_pid[maxChild] = { 0 };             

// MAIN
int main(int argc, char *argv[]) {
	// signal(SIGINT, sig_handler);
    srand(time(NULL));                         
    int child_sel;                             
    int ShmKEY  = ftok(".", 43);        
    int SemKEY1 = ftok(".", 44);          
    int SemKEY2  = ftok(".", 45);      
    int sleep_secs, i, x;                                 

	printf("It will run for 100 seconds\n");
	
	// Shared Memory Initialization
    ShmID = shmget(ShmKEY, IPCD_SZ, 0600 | IPC_CREAT);
    if (ShmID == -1) {
		perror("shmget Err");
        exit(1);
    }
    if ( ! (ShmPTR = (ShmPTR_t *)(shmat(ShmID, 0, 0)))) {
		perror("shmat Err");
        exit(1);
    }
	writelog("Successfully allocated and attached to shared memory for IPC");

	// Semaphore Memory Initialization for Clock
    if ((SemID_clock = semget(SemKEY1, 1, 0600 | IPC_CREAT)) == -1) {
		perror("semget Err clock");
        exit(1);
    }
	// Semaphore Memory Initialization for Resource
    if ((SemID_res = semget(SemKEY2, 1, 0600 | IPC_CREAT)) == -1) {
		perror("semget Err resource");
        exit(1);
    }
	// Initialization
	semInit();
	resInit();
    for (i = 0; i < maxChild; i++) ShmPTR->childTaken[i] = 0;
	writelog("Successfully created and initialized semaphores");
	
    // Go into fork loop
    while (1) {
        if ( sigcheck() ) break;
        
		resManage();
		resAllocation();

        // Only attempt a fork another child if we are below maxChild processes
        if ( countChild() < maxChild ) {
            // Determine which child to fork
            for (i = 0; i <= maxChild; i++) {
                if ( ShmPTR->childTaken[i] == 0 ) {
                    child_sel = i;
                    break;
                }
            }
            sprintf(msgerr, "Selected child number %d to fork", child_sel);
            writelog(msgerr);
            fork_child(child_sel);
        }

        sem_wait(SemID_clock);             
		updateClock();
        sem_signal(SemID_clock);               

        sprintf(msgerr, "Logical clock is now %d.%03d", ShmPTR->secTime, ShmPTR->milliTime);
        sprintf(msgerr, "%s.%03d", msgerr, ShmPTR->nanoTime);
        writelog(msgerr);

        // Break if we have reached 100 elapsed seconds
        if (ShmPTR->secTime >= 100) {
            sprintf(msgerr, "Reached maximum run time - exiting.");
            writelog(msgerr);
            break;
        }
		report();

        // Write log entry and sleep
        sleep_secs = rand() % 2;                 // Random from 0 to 1
        sprintf(msgerr, "Sleep %d", sleep_secs);
        writelog(msgerr);
        sleep(sleep_secs);
    }
	// Report Final Result
	report();
	
    cleanup(SIGTERM);             
    return 0;
}

// The function will allocate resources based on updated allocation and new requests
void resAllocation() {
		int need;		// Allocation need
		int i, x;
		for (i = 0; i < resMax; i++) {
            for (x = 0; x < maxChild; x++) {
                if (ShmPTR->resources[i].request[x] > 0) {
                    // Calculating amount of resources child wants
                    need = ShmPTR->resources[i].max_claim[x] - ShmPTR->resources[i].allocated[x];

					// If childrend Request more than MAX
                    if ( ShmPTR->resources[i].request[x] > need ||
                            ShmPTR->resources[i].allocated[x] + ShmPTR->resources[i].request[x] >
                            ShmPTR->resources[i].inst_tt) {
                        sprintf(msgerr, "%s Request denied : MAX resources", msgerr);
                        writelog(msgerr);

                        sem_wait(SemID_res);
                        ShmPTR->resources[i].request[x] = -1;
                        sem_signal(SemID_res);
                        // Deadlock detection algorithm
                    } else if ( ShmPTR->resources[i].request[x] <= ShmPTR->resources[i].inst_avail ) {
						ShmPTR->throughput[x] += ShmPTR->resources[i].request[x];

						// Allocate the resource
						sprintf(msgerr, "Child %02d has allocated %d", x, ShmPTR->resources[i].request[x]);
						sprintf(msgerr, "%s of resource %d", msgerr, i);
						writelog(msgerr);

						ShmPTR->resources[i].inst_avail -= ShmPTR->resources[i].request[x];
						ShmPTR->resources[i].allocated[x] += ShmPTR->resources[i].request[x];

						sem_wait(SemID_res);
						ShmPTR->resources[i].request[x] = 0;
						sem_signal(SemID_res);
                    }
                }
            }
        }
}

// The function will determine who has released resources and update the resource data
void resManage() {
	int i, x;
		for (i = 0; i < resMax; i++) {
            for (x = 0; x < maxChild; x++) {
                if ( ShmPTR->resources[i].release[x] != 0 ) {
                    sprintf(msgerr, "Child %02d has released %d", x, ShmPTR->resources[i].release[x]);
                    sprintf(msgerr, "%s instances of resource %d", msgerr, i);
                    writelog(msgerr);

                    ShmPTR->resources[i].inst_avail += ShmPTR->resources[i].release[x];

                    sem_wait(SemID_res);
                    ShmPTR->resources[i].release[x] = 0;
                    sem_signal(SemID_res);
                }
            }
        }
}
void updateClock() {
        ShmPTR->milliTime += rand() % 1000;      //  Random 0 to 999
        if ( ShmPTR->milliTime >= 1000 ) {
            ShmPTR->secTime++;
            ShmPTR->milliTime -= 1000;
        }
        ShmPTR->nanoTime += rand() % 1000;       //  Random 0 to 999
        if ( ShmPTR->nanoTime >= 1000 ) {
            ShmPTR->milliTime++;
            ShmPTR->nanoTime -= 1000;
        }

}
void report() {
		int i;
	    unsigned int tp_tt = 0, wt_tt = 0;        
		unsigned long cu_tt = 0;                    
		float avg_tp, avg_tt, avg_wt;            
		float avg_cu;                             

        for (i = 0; i < maxChild; i++) {
            tp_tt += ShmPTR->throughput[i];     // throughput
            wt_tt += ShmPTR->wait_time[i];       // waitt ime
            cu_tt += ShmPTR->cpu_util[i];         // cpu utilization
        }

        if ( maxChild > 0 ) {                   // Handle possibility of divide by zero
            avg_tp = (float)tp_tt / maxChild;  // average throughput
			
            // average turnaround time
            if ( tp_tt > 0 ) avg_tt = ((float)wt_tt / tp_tt) / maxChild;
            avg_wt = (float)wt_tt / maxChild;  // average wait time
            avg_cu = ((float)cu_tt / maxChild) / 1000000;  // average cpu time
        }
		
		printf("\n=== Averages for Completed Processes ===\n");
        printf("Throughput:\t\t%.2f allocations/process\n", avg_tp);
        printf("Turnaround Time:\t%.2f ms\n", avg_tt);
        printf("Wait Time:\t\t%.2f ms\n", avg_wt);
        printf("CPU Utilization:\t%.2f ms\n\n", avg_cu);

		printf("=== Total Time in System ===\n");
        printf("%d.%03d.%03d \n\n ", ShmPTR->secTime, ShmPTR->milliTime, ShmPTR->nanoTime);
}
void resInit() {
	int x, i;
	int noShared;                             
	
    noShared = resMax * ((float)(15 + (rand() % 10)) / 100);
    sprintf(msgerr, "Determined that %d of %d resources will be shared", noShared, resMax);
    writelog(msgerr);

    for (i = 0; i < resMax; i++) {
        // Randomly set  number of instances for the resource
        ShmPTR->resources[i].inst_tt = 1 + (rand() % instMax);
        ShmPTR->resources[i].inst_avail = ShmPTR->resources[i].inst_tt;

        sprintf(msgerr, "Resource %d will have %d instances", i, ShmPTR->resources[i].inst_tt);
        writelog(msgerr);

        if ( i <= noShared ) {
            ShmPTR->resources[i].shared = 1;

            sprintf(msgerr, "Resource %d will be shared", i);
            writelog(msgerr);
        } else ShmPTR->resources[i].shared = 0;

        for (x = 0; x < maxChild; x++) {
            ShmPTR->resources[i].max_claim[x] = 0;
            ShmPTR->resources[i].request[x] = 0;
            ShmPTR->resources[i].allocated[x] = 0;
            ShmPTR->resources[i].release[x] = 0;
        }
    }
    writelog("Initialized resources");
}
void semInit() {
    union semun { int val; struct semid_ds *buf; ushort * array; } argument;
    argument.val = 1;                            // Set the semaphore value to one
    if (semctl(SemID_clock, 0, SETVAL, argument) == -1) {
        sprintf(msgerr, "oss: semctl (clock)");
        perror(msgerr);
        exit(1);
    }
    if (semctl(SemID_res, 0, SETVAL, argument) == -1) {
        sprintf(msgerr, "oss: semctl (resources)");
        perror(msgerr);
        exit(1);
    }
    writelog("Created and initialized clock and resource semaphores to 1");

    sem_wait(SemID_clock);                       
    ShmPTR->secTime = 0;
    ShmPTR->nanoTime = 0;
    sem_signal(SemID_clock);                     
}

void sigproc(int sig) {
    signum = sig;
}

int sigcheck() {
    signal(SIGINT, sigproc);
    signal(SIGTERM, sigproc);
    return 0;
}

void writelog(char *msg) {

    FILE *fp;
    if (!(fp = fopen("oss.log", "a"))) {
        perror("oss: opening oss.log");
        exit(1);
    }
    time_t now;
    struct tm *timeinfo;
    time(&now);
    timeinfo = localtime(&now);
	
    fprintf(fp, "%02d:%02d:%02d\t", timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
    fprintf(fp, "oss:\t%s\n", msg);
    fclose(fp);
}


int term_proc(int child, int sig) {
    int status;                                  // Hold status from wait()
    kill(child_pid[child], sig);
    wait(&status);
    return WEXITSTATUS(status);
}

void cleanup(int termsig) {
    int i;
    for (i = 0; i < maxChild; i++) {
        if ( ShmPTR->childTaken[i] > 0 ) {
            if ( term_proc(i, termsig) != 0 ) {
                sprintf(msgerr, "There was an issue terminating child %02d", i);
                writelog(msgerr);
            }
        }
    }

    int ShmPTR_ret = shmctl(ShmID, IPC_RMID, (struct shmid_ds *)NULL);
    if ((semctl(SemID_clock, 0, IPC_RMID, 1) == -1) && (errno != EINTR)) {
        sprintf(msgerr, "oss: clock removed");
        perror(msgerr);
    }
	
    if ((semctl(SemID_res, 0, IPC_RMID, 1) == -1) && (errno != EINTR)) {
        sprintf(msgerr, "oss: resources removed");
        perror(msgerr);
    }
    return;
}

// Counting Child Function
int countChild() {
    int i, count = 0;
    for (i = 0; i < maxChild; i++) {
        if ( ShmPTR->childTaken[i] == 0 && child_pid[i] > 0 ) {
            sprintf(msgerr, "Child %02d has exited - attempting to clean it up", i);
            writelog(msgerr);

            if ( term_proc(i, SIGTERM) != 0 ) {
                sprintf(msgerr, "There was an issue terminating child %02d", i);
                writelog(msgerr);
                cleanup(SIGTERM);
                exit(1);
            }
            child_pid[i] = 0;
        }

        if ( ShmPTR->childTaken[i] ) count++;
    }
    sprintf(msgerr, "Current child count is %d", count);
    writelog(msgerr);
    return count;
}

// Forking Child Function
void fork_child(int child) {
    char child_arg[5] = "";                        // String to hold child argument

    if ((child_pid[child] = fork()) < 0) {
        sprintf(msgerr, "oss: fork() for child %02d", child);
        perror(msgerr);
        writelog("Error forking child");
        cleanup(SIGTERM);
        exit(1);
    } else {
        if (child_pid[child] == 0) {
            sprintf(child_arg, "%02d", child);
            execl("./uproc", "uproc", child_arg, (char *)NULL);
            sprintf(msgerr, "oss: exec child %02d after fork", child);
            perror(msgerr);
        } else {
            sprintf(msgerr, "Forked process ID %d for child %02d", child_pid[child], child);
            writelog(msgerr);
            sprintf(msgerr, "Setting child %02d status 'running'", child);
            writelog(msgerr);
            ShmPTR->childTaken[child] = 1;
        }
    }
    return;
}

// Wait Function
void sem_wait(int semid) {
	struct sembuf sbuf;			
	sbuf.sem_num = 0;							
	sbuf.sem_op = -1;							
	sbuf.sem_flg = 0;							
	if (semop(semid, &sbuf, 1) == -1)  {
			exit(0);
	}
	return;
}

// Singal Function
void sem_signal(int semid) {
	struct sembuf sbuf;						
	sbuf.sem_num = 0;							
	sbuf.sem_op = 1;						
	sbuf.sem_flg = 0;						
	if (semop(semid, &sbuf, 1) == -1)  {
			exit(1);
	}
	return;
}
@

1.5
log
@Add running child counter
Add PCB de-allocator
Add semaphore scheduler wait
Add PCB used vector check
@
text
@d110 2
a111 2
	ipcd->child_pcb[child].time_last = 0;
	ipcd->child_pcb[child].cpriority = 0;
d285 1
a285 1
			PROCESS SCHEDULING ROUTINE
d293 8
a300 2
		// Blah
		// Blah
d334 1
a334 1
@


1.4
log
@Add PCB selection routine
@
text
@d17 1
a17 1
#define CHILD_COUNT 18							// Number of spawned children
d84 1
a84 1
	for (i = 0; i < CHILD_COUNT; i++) {
d112 28
d150 1
a150 1
	int pcb_taken[18];							// "PCB taken by PID" array/bit vector
d153 3
a155 1
	int pcb_index;								// Relative search position for available PCB
d191 2
a192 3
	int i;
	for (i = 0; i < CHILD_COUNT; pcb_taken[i++] = 0);
	for (i = 0; i < CHILD_COUNT; i++) if (DEBUGM) printf("oss: pcb_taken[%d] = %d\n", i, pcb_taken[i]);
d201 2
a202 2
	// Initialize the semaphore
	if (semctl(semid_oss, 0, SETVAL, 1) == -1) {
d219 1
d224 5
a228 1
		// WE NEED A WAY TO DEALLOCATE PCB's, OR ELSE WE WILL GET STUCK IN THE BELOW FOR LOOP
d230 2
a231 14
		// Determine which PCB to use by fork'd child
		for (child_num = pcb_index; child_num <= CHILD_COUNT; child_num++) {
			// See if we have reached the end of the bit vector. If so, loop back to the beginning
			if ( child_num == CHILD_COUNT ) {
				pcb_index = 0;
				if (DEBUGM) printf("oss: Reached end of PCB bit vector - looping around\n");
				continue;
			}
			if ( ! pcb_taken[child_num] ) {
				if (DEBUGM) printf("oss: Setting child PCB %d to 'allocated'\n", child_num);
				pcb_child[child_num] = 1;
				pcb_index = child_num;
				break;
			}
a232 1
		if (DEBUGM) printf("oss: Selected child number %d to fork\n", child_num);
d234 2
a235 2
		// Initialize the PCB for this child process and set the bit flag to used
		init_pcb(child_num);
d237 19
d257 3
a259 13
		if ((child_pid[child_num] = fork()) < 0) {
			sprintf(msgerr, "oss: fork() for child %02d", child_num);
			perror(msgerr);
			cleanup(SIGINT);
			exit(1);
		} else {
			if (child_pid[child_num] == 0) {
				// exec child
				sprintf(child_arg, "%02d", child_num);
				execl("./userproc", "userproc", child_arg, (char *)NULL);
	
				// Handle execl() error, if one occurs
				sprintf(msgerr, "oss: exec child %02d after fork", child_num);
d261 16
d278 1
a278 2
				// This is the parent; write to oss log about fork()
				sprintf(msgerr, "Forked process ID %d for child %02d", child_pid[child_num], child_num);
d283 14
d306 1
a306 1
		sleep_secs = rand() % 3;				// Random from 0 to 2, average of 1
d328 1
a328 1
d331 3
@


1.3
log
@Added semaphore allocation/initialization/cleanup
@
text
@d9 1
d16 1
a16 1
#define DEBUGM 0								// Enable debugging = 1
d27 1
d99 2
a100 2
		sprintf(mon_err, "oss: cleanup->semctl");
		perror(mon_err);
d125 1
d163 1
d190 22
a211 3
		// Advance the clock
		ipcd->clock_sec++;
		ipcd->clock_nano = 1 + (rand() % 1000);	//  Random 1 to 1000
d213 2
a214 2
		// Fork and exec children
		//for (child_num = 0; child_num < CHILD_COUNT; child_num++) {
a215 2
		// Determine which child to fork
		child_num = 0;
d217 13
a229 7
			// Initialize the PCB for this child process and set the bit flag to used
			init_pcb(child_num);
			pcb_taken[child_num] = 1;


			if ((child_pid[child_num] = fork()) < 0) {
				sprintf(msgerr, "oss: fork() for child %02d", child_num);
a230 2
				cleanup(SIGINT);
				exit(1);
d232 3
a234 13
				if (child_pid[child_num] == 0) {
					// exec child
					sprintf(child_arg, "%02d", child_num);
					execl("./userproc", "userproc", child_arg, (char *)NULL);
		
					// Handle execl() error, if one occurs
					sprintf(msgerr, "oss: exec child %02d after fork", child_num);
					perror(msgerr);
				} else {
					// This is the parent; write to oss log about fork()
					sprintf(msgerr, "Forked process ID %d for child %02d", child_pid[child_num], child_num);
					writelog(msgerr);
				}
d236 5
a240 1
		//}
d242 3
d247 1
a247 1
		sleep_secs = rand() % 2;				// Random from 0 to 1
d269 1
a269 1
d272 3
@


1.2
log
@Add shared memory allocation and access
Add logical and PCB initialization routines
Add clock advancement commands
Update random sleep time (0 to 1 seconds)
@
text
@d5 1
d9 1
d11 2
a12 2
#include <sys/ipc.h>							// Inter-process communication
#include "ipcd_data.h"							// IPC Data structure
d39 2
a40 4
	if (signum) {
		if (signum == 2) {
			fprintf(stderr, "oss: Caught CTRL-C (SIGINT)\n");
		}
d95 6
d106 4
a109 4
	ipcd->child_pcb[child]->total_cpu = 0;
	ipcd->child_pcb[child]->total_sys = 0;
	ipcd->child_pcb[child]->time_last = 0;
	ipcd->child_pcb[child]->cpriority = 0;
d122 1
d157 18
d194 1
d216 1
a216 1
					// This is the parent; write to oss log about fork() and update the pcb_taken array
d247 1
a247 1
d250 6
@


1.1
log
@Initial revision
@
text
@d15 1
d23 1
d29 1
a29 1
void sigcheck(int sig) {
d34 3
a36 3
int sigproc() {
	signal(SIGINT, sigcheck);
	signal(SIGTERM, sigcheck);
d39 1
a39 1
			fprintf(stderr, "oss: Caught CTRL-C\n");
d98 8
d107 2
d114 40
a153 1
	int pcb_taken[18];							// "PCB taken by PID" array 
d158 18
a175 3
		// Fork and exec childs
		for (child_num = 0; child_num < CHILD_COUNT; child_num++) {
			if ((child_pid[c] = fork()) < 0) {
d184 1
a184 1
					execl("./child", "child", child_arg, (char *)NULL);
d190 1
a190 1
					// Log to oss log about fork()
d195 1
a195 1
		}
d199 1
a199 2
		srand(time(NULL));							// Seed the random number generator
		sleep_secs = 1 + (rand()) % 5;				// Random from 1 to 5
d205 9
d220 7
a226 4
// $Author:  $
// $Date:  $
// $RCSfile:  $
// $Log:  $
@
